### 什么变量在堆内存里存放，什么变量在栈内存里存放 
一般认为在c中分为这几个存储区 
1栈 - 有编译器自动分配释放 
2堆 - 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收 
3全局区（静态区），全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 程序结束释放。
4另外还有一个专门放常量的地方。 - 程序结束释放

在函数体中定义的变量通常是在栈上，用malloc, calloc, realloc等分配内存的函数分配得到的就是在堆上。在所有函数体外定义的是全局量，加了static修饰符后不管在哪里都存放在全局区（静态区）,在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用，在函数体内定义的static表示只在该函数体内有效。另外，函数中的 "adgfdf "这样的字符串存放在常量区。
比如： 

```
#include<stdio.h>  
  
int a = 0;                  //全局初始化区  
char *p1;                   //全局未初始化区  
main()  
{  
    int b;                  //栈  
    char s[] = "abc ";      //栈  
    char *p2;               //栈  
    char *p3 = "123456 ";   //123456\0在常量区，p3在栈上。  
    static int c = 0;       //全局（静态）初始化区  
    p1 = (char *)malloc(10);  
    p2 = (char *)malloc(20);  
    //分配得来得10和20字节的区域就在堆区。  
    strcpy(p1, "123456 ");  //123456\0放在常量区，编译器可能会将它与p3所指向的 "123456 "优化成一块。   
}  
```
 还有就是函数调用时会在栈上有一系列的保留现场及传递参数的操作。栈的空间大小有限定，vc的缺省是2M。栈不够用的情况一般是程序中分配了大量数组和递归函数层次太深。有一点必须知道，当一个函数调用完返回后它会释放该函数中所有的栈空间。栈是由编译器自动管理的，不用你操心。堆是动态分配内存的，并且你可以分配使用很大的内存。但是用不好会产生内存泄漏。并且频繁地malloc和free会产生内存碎片（有点类似磁盘碎片），因为c分配动态内存时是寻找匹配的内存的。而用栈则不会产生碎片。在栈上存取数据比通过指针在堆上存取数据快些。
 
一般大家说的堆栈和栈是一样的，就是栈(stack)，而说堆时才是堆heap.栈是先入后出的，一般是由高地址向低地址生长。 

堆(heap)和栈(stack)是C/C++编程不可避免会碰到的两个基本概念。首先，这两个概念都可以在讲数据结构的书中找到，他们都是基本的数据结构，虽然栈更为简单一些。在具体的C/C++编程框架中，这两个概念并不是并行的。对底层机器代码的研究可以揭示，栈是机器系统提供的数据结构，而堆则是C/C++函数库提供的。具体地说，现代计算机(串行执行机制)，都直接在代码底层支持栈的数据结构。这体现在，有专门的寄存器指向栈所在的地址，有专门的机器指令完成数据入栈出栈的操作。这种机制的特点是效率高，支持的数据有限，一般是整数，指针，浮点数等系统直接支持的数据类型，并不直接支持其他的数据结构。因为栈的这种特点，对栈的使用在程序中是非常频繁的。对子程序的调用就是直接利用栈完成的。机器的call指令里隐含了把返回地址推入栈，然后跳转至子程序地址的操作，而子程序中的ret指令则隐含从堆栈中弹出返回地址并跳转之的操作。C/C++中的自动变量是直接利用栈的例子，这也就是为什么当函数返回时，该函数的自动变量自动失效的原因(因为 颜换指戳说饔们暗 状态)。 

和栈不同，堆的数据结构并不是由系统(无论是机器系统还是操作系统)支持的，而是由函数库提供的。基本的malloc/realloc/free函数维护了一套内部的堆数据结构。当程序使用这些函数去获得新的内存空间时，这套函数首先试图从内部堆中寻找可用的内存空间，如果没有可以使用的内存空间，则试图利用系统调用来动态增加程序数据段的内存大小，新分配得到的空间首先被组织进内部堆中去，然后再以适当的形式返回给调用者。当程序释放分配的内存空间时，这片内存空间被返回内部堆结构中，可能会被适当的处理(比如和其他空闲空间合并成更大的空闲空间)，以更适合下一次内存分配申请。这套复杂的分配机制实际上相当于一个内存分配的缓冲池(Cache)，使用这套机制有如下若干原因：

1. 系统调用可能不支持任意大小的内存分配。有些系统的系统调用只支持固定大小及其倍数的内存请求(按页分配)；这样的话对于大量的小内存分类来说会造成浪费。
2. 系统调用申请内存可能是代价昂贵的。系统调用可能涉及用户态和核心态的转换。 
3. 没有管理的内存分配在大量复杂内存的分配释放操作下很容易造成内存碎片。 

**堆和栈的对比** 

从以上知识可知，栈是系统提供的功能，特点是快速高效，缺点是有限制，数据不灵活；而堆是函数库提供的功能，特点是灵活方便，数据适应面广泛，但是效率有一定降低。栈是系统数据结构，对于进程/线程是唯一的；堆是函数库内部数据结构，不一定唯一。不同堆分的内存无法互相操作。栈空间分静态分配和动态分配两种。静态分配是编译器完成的，比如自动变量(auto)的分配。动态分配由alloca函数完成。栈的动态分配无需释放(是自动)，也就没有释放函数。为可移植的程序起见，栈的动态分配操作是不被鼓励的！堆空间的分配总是动态的，虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存/释放内存匹配是良好程序的基本要素。

可以放一块思考 
堆和栈的生长方向恰好相反， 
|--------------| 低地址 
| 堆 | 
|--------------| 
| | | 
| I | 
| | 
| ^ | 
| 栈 | 高地址 
----------------- 
所以计算机中的堆和栈经常时放一块讲的 

注： 一般不是必要就不要动态创建，最讨厌把new出来的东西当局部变量用，用完了马上delete 的做法.

理由 
1.栈分配比堆快，只需要一条指令就呢给配所有的局部变量 
2.栈不会出现内存碎片 
3。栈对象好管理 

当然，某些情况下也要用堆,比如 
1.对象很大 
2.对象需要在某个特定的时刻构造或析够 
3.类只允许对象动态创建,比如VCL的大多数类 
当然，必须用堆对象时也不能躲避
2 堆内存和栈内存各有什么作用？
堆：顺序随意
栈：先进后出
堆和栈的区别

#### 一、预备知识—程序的内存分配
一个由c/C++编译的程序占用的内存分为以下几个部分
1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈
2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放
4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放
5、程序代码区—存放函数体的二进制代码。

#### 二、堆和栈的理论知识
##### 2.1申请方式
stack:由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间
heap:需要程序员自己申请，并指明大小，在c中malloc函数如p1 = (char *)malloc(10);在C++中用new运算符如p2 = (char *)malloc(10);但是注意p1、p2本身是在栈中的
##### 2.2申请后系统的响应
栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。
##### 2.3申请大小的限制
栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。
堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
##### 2.4申请效率的比较：
栈由系统自动分配，速度较快。但程序员是无法控制的。
堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便. 另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活
##### 2.5堆和栈中的存储内容
栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 
##### 2.7小结：
堆和栈的区别可以用如下的比喻来看出：使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。 使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。
**堆和栈的区别主要分**
操作系统方面的堆和栈，如上面说的那些，不多说了。还有就是数据结构方面的堆和栈，这些都是不同的概念。这里的堆实际上指的就是（满足堆性质的）优先队列的一种数据结构，第1个元素有最高的优先权；栈实际上就是满足先进后出的性质的数学或数据结构。虽然堆栈，堆栈的说法是连起来叫，但是他们还是有很大区别的，连着叫只是由于历史的原因。

#### 3 深入理解堆栈、堆在内存中的实现
引自[深入理解堆栈、堆在内存中的实现](<http://www.cnblogs.com/tianzhiliang/archive/2010/09/19/1830763.html>)
##### 3.1  栈vs堆：有什么不同？
栈负责保存我们的代码执行（或调用）路径,而堆则负责保存对象（或者说数据，接下来将谈到很多关于堆的问题）的路径。

可以将栈想象成一堆从顶向下堆叠的盒子。当每调用一次方法时，我们将应用程序中所要发生的事情记录在栈顶的一个盒子中,而我们每次只能够使用栈顶的那个盒子。当我们栈顶的盒子被使用完之后，或者说方法执行完毕之后，我们将抛开这个盒子然后继续使用栈顶上的新盒子。堆的工作原理比较相似，但大多数时候堆用作保存信息而非保存执行路径，因此堆能够在任意时间被访问。与栈相比堆没有任何访问限制，堆就像床上的旧衣服，我们并没有花时间去整理，那是因为可以随时找到一件我们需要的衣服，而栈就像储物柜里堆叠的鞋盒，我们只能从最顶层的盒子开始取，直到发现那只合适的。
![](https://ws3.sinaimg.cn/large/006tNc79gy1fo26kxjzv7j30fy0bwmxy.jpg)
以上图片并不是内存中真实的表现形式，但能够帮助我们区分栈和堆。

栈是自行维护的，也就是说内存自动维护栈，当栈顶的盒子不再被使用，它将被抛出。相反的，堆需要考虑垃圾回收，垃圾回收用于保持堆的整洁性，没有人愿意看到周围都是赃衣服，那简直太臭了！

##### 3.2 栈和堆里有些什么？
当我们的代码执行的时候，栈和堆中主要放置了四种类型的数据：值类型(Value Type)，引用类型(Reference Type)，指针(Pointer)，指令(Instruction)。
1.值类型：
在C#中，所有被声明为以下类型的事物被称为值类型：
bool 
byte 
char 
decimal 
double 
enum 
float 
int 
long 
sbyte 
short 
struct 
uint 
ulong 
ushort

2.引用类型：
所有的被声明为以下类型的事物被称为引用类型：
class 
interface 
delegate 
object 
string

3.指针：
在内存管理方案中放置的第三种类型是类型引用，引用通常就是一个指针。我们不会显示的使用指针，它们由公共语言运行时（CLR）来管理。指针（或引用）是不同于引用类型的，是因为当我们说某个事物是一个引用类型时就意味着我们是通过指针来访问它的。指针是一块内存空间，而它指向另一个内存空间。就像栈和堆一样，指针也同样要占用内存空间，但它的值是一个内存地址或者为空。
![](https://ws3.sinaimg.cn/large/006tNc79gy1fo26l9loqoj30g50c60to.jpg)
![](https://ws3.sinaimg.cn/large/006tNc79gy1fo26m9vpuzj30jc5d3ww2.jpg)

#### 4 内存分配详解
引自[内存分配详解](<http://www.cnblogs.com/skynet/archive/2011/03/07/1975479.html>)
为什么需要知道C/C++的内存布局和在哪可以可以找到想要的数据？知道内存布局对调试程序非常有帮助，可以知道程序执行时，到底做了什么，有助于写出干净的代码。本文的主要内容如下：

源文件转换为可执行文件
可执行程序组成及内存布局
数据存储类别
一个实例
总结
##### 4.1源文件转换为可执行文件
源文件经过以下几步生成可执行文件：
1、预处理（preprocessor）：对#include、#define、#ifdef/#endif、#ifndef/#endif等进行处理
2、编译（compiler）：将源码编译为汇编代码
3、汇编（assembler）：将汇编代码汇编为目标代码
4、链接（linker）：将目标代码链接为可执行文件
编译器和汇编器创建的目标文件包含：二进制代码（指令）、源码中的数据；链接器将多个目标文件链接成一个；装载器吧目标文件加载到内存。
![](https://ws3.sinaimg.cn/large/006tNc79gy1fo26pylqadj30jo05ujrw.jpg)
##### 4.2 可执行程序组成及内存布局
通过上面的小节，我们知道将源程序转换为可执行程序的步骤，典型的可执行文件分为两部分：
代码段（Code），由机器指令组成，该部分是不可改的，编译之后就不再改变，放置在文本段（.text）。
数据段（Data），它由以下几部分组：
常量（constant），通常放置在只读read-only的文本段（.text）
静态数据（static data），初始化的放置在数据段（.data）；未初始化的放置在（.bss，Block Started by Symbol，BSS段的变量只有名称和大小却没有值）
动态数据（dynamic data），这些数据存储在堆（heap）或栈（stack）
源程序编译后链接到一个以0地址为始地址的线性或多维虚拟地址空间。而且每个进程都拥有这样一个空间，每个指令和数据都在这个虚拟地址空间拥有确定的地址，把这个地址称为虚拟地址（Virtual Address）。将进程中的目标代码、数据等的虚拟地址组成的虚拟空间称为虚拟存储器（Virtual Memory）。典型的虚拟存储器中有类似的布局：
Text Segment (.text)
Initialized Data Segment (.data)
Uninitialized Data Segment (.bss)
The Stack
The Heap
如下图所示：
![](https://ws3.sinaimg.cn/large/006tNc79gy1fo26qd535gj30jh07aq3l.jpg)
当进程被创建时，内核为其提供一块物理内存，将虚拟内存映射到物理内存，这些都是由操作系统来做的。
##### 4.3 数据存储类别
讨论C/C++中的内存布局，不得不提的是数据的存储类别！数据在内存中的位置取决于它的存储类别。一个对象是内存的一个位置，解析这个对象依赖于两个属性：存储类别、数据类型。
存储类别决定对象在内存中的生命周期。
数据类型决定对象值的意义，在内存中占多大空间。
C/C++中由（auto、 extern、 register、 static）存储类别和对象声明的上下文决定它的存储类别。
1、自动对象（automatic objects）
auto和register将声明的对象指定为自动存储类别。他们的作用域是局部的，诸如一个函数内，一个代码块{***}内等。操作了作用域，对象会被销毁。
在一个代码块中声明一个对象，如果没有执行auto，那么默认是自动存储类别。
声明为register的对象是自动存储类别，存储在计算机的快速寄存器中。不可以对register对象做取值操作“&”。
2、静态对象（static objects）
静态对象可以局部的，也可以是全局的。静态对象一直保持它的值，例如进入一个函数，函数中的静态对象仍保持上次调用时的值。包含静态对象的函数不是线程安全的、不可重入的，正是因为它具有“记忆”功能。
局部对象声明为静态之后，将改变它在内存中保存的位置，由动态数据--->静态数据，即从堆或栈变为数据段或bbs段。
全局对象声明为静态之后，而不会改变它在内存中保存的位置，仍然是在数据段或bbs段。但是static将改变它的作用域，即该对象仅在本源文件有效。此相反的关键字是extern，使用extern修饰或者什么都不带的全局对象的作用域是整个程序。

```
#include <stdio.h>  
#include <stdlib.h>  
   
int a;  
static int b;  
void func( void )  
{  
    char c;  
    static int d;  
}  
int main( void )  
{  
    int e;  
    int *pi = ( int *) malloc ( sizeof ( int ));  
    func ();  
    func ();  
    free (pi );  
    return (0);  
}  
```
程序中声明的变量a、b、c、d、e、pi的存储类别和生命期如下所述：
a是一个未初始化的全局变量，作用域为整个程序，生命期是整个程序运行期间，在内存的bbs段
b是一个未初始化的静态全局变量，作用域为本源文件，生命期是整个程序运行期间，在内存的bbs段
c是一个未初始化的局部变量，作用域为函数func体内，即仅在函数体内可见，生命期也是函数体内，在内存的栈中
d是一个未初始化的静态局部变量，作用域为函数func体内，即仅在函数体内可见，生命期是整个程序运行期间，在内存的bbs段
e是一个未初始化的局部变量，作用域为函数main体内，即仅在函数体内可见，生命期是main函数内，在内存的栈中
pi是一个局部指针，指向堆中的一块内存块，该块的大小为sizeof(int)，pi本身存储在内存的栈中，生命期是main函数内
新申请的内存块在堆中，生命期是malloc/free之间
用图表示如下：
![](https://ws3.sinaimg.cn/large/006tNc79gy1fo26xyuz18j30bg0aa3z7.jpg)
##### 4.4 总结
本文介绍了C/C++中由源程序到可执行文件的步骤，和可执行程序的内存布局，数据存储类别，最后还通过一个例子来说明。可执行程序中的变量在内存中的布局可以总结为如下：
变量（函数外）：如果未初始化，则存放在BSS段；否则存放在data段
变量（函数内）：如果没有指定static修饰符，则存放在栈中；否则同上
常量：存放在文本段.text
函数参数：存放在栈或寄存器中
内存可以分为以下几段：
文本段：包含实际要执行的代码（机器指令）和常量。它通常是共享的，多个实例之间共享文本段。文本段是不可修改的。
初始化数据段：包含程序已经初始化的全局变量，.data。
未初始化数据段：包含程序未初始化的全局变量，.bbs。该段中的变量在执行之前初始化为0或NULL。
栈：由系统管理，由高地址向低地址扩展。
堆：动态内存，由用户管理。通过malloc/alloc/realloc、new/new[]申请空间，通过free、delete/delete[]释放所申请的空间。由低地址想高地址扩展。




